# -*- coding: utf-8 -*-
"""
Created on Fri Aug 27 10:45:27 2021

@author: Avijit.Nandy
"""

import numpy as np
import pandas as pd

from statsmodels.tsa.vector_ar.vecm import coint_johansen
from statsmodels.tsa.vector_ar.vecm import VECM, select_order


import aggregation_helper_functions as ahf

def model_2():

    df = pd.read_csv('Input/Model 2/ON Data LatestData_Collection.csv', index_col=0,parse_dates=True)
    exog = pd.read_csv('Input/Model 2/Exog Workplace_oil.csv', index_col=0,parse_dates=True)
    df.index.freq = "Q"
    exog.index.freq = "Q"
    
    Model2Data = df
    
    df['lConsumption'] = np.log(df['Consumption'])
    df['lCPI'] = np.log(df['CPI'])
    df['lResidentialInvestment'] = np.log(df['ResidentialInvestment'])
    df['lCREPriceIndex'] = np.log(df['CREPriceIndex'])
    df['lNominalMortgageDebt'] = np.log(df['NominalMortgageDebt'])
    df2 = df.drop(['Consumption', 'CPI', 'ResidentialInvestment', 'CREPriceIndex','NominalMortgageDebt', '3M_InterestRate'], axis = 1)
    df2 = df2[['lConsumption','lNominalMortgageDebt','lCREPriceIndex','lCPI','30YFixedMortgageRate','lResidentialInvestment']]
    
    #   
    #With constant "0", lagorder "2"
    mod1 = coint_johansen(df2,0,1)
    output = pd.DataFrame([mod1.lr2,mod1.lr1],index=['Max Eigen',"Trace"])
    print('\nCE w/constant intercept\n' ,output.T, '\n')
    print("Critical values(90%, 95% , 99%) of Max Eign\n" , mod1.cvm , '\n')
    print("Critical values(90%, 95% , 99%) of Trace\n" , mod1.cvt, '\n')
    
      
    lo = select_order(df2,maxlags = 7)
    lo.selected_orders
    
    #aic criterion gives 2 lag
    #ar_diff is lag order, coint_rank in no of co integrated reationship
    Model = VECM(df2,exog = exog,k_ar_diff = 4, coint_rank = 2, deterministic= 'co')
    Model_res = Model.fit()
    
    #Granger Causalty test
    ahf.Casualty_test(df2,Model_res).to_csv('Output/Model 2/CausaltyTestResults.csv')
    
    #H_0: data generated by normally-distributed process
    normtest = Model_res.test_normality()
    print(normtest)
    print(normtest.conclusion)
    #failing normality tests
    
    #Autocorreleation test
    ahf.AutoCorrtest(Model_res,10).to_csv('Output/Model 2/AutocorreleationTestResults.csv')
    
    #Forecast
    forecast_extract = pd.DataFrame()
    for i in range(19):
        forecast_extract = forecast_extract.append({'lConsumption':Model_res.predict(steps = len(exog), exog_fc = exog)[i][0],
                                                    'lNominalMortgageDebt':Model_res.predict(steps = len(exog), exog_fc = exog)[i][1],
                                                    'lCREPriceIndex':Model_res.predict(steps = len(exog), exog_fc = exog)[i][2],
                                                    'lCPI':Model_res.predict(steps = len(exog), exog_fc = exog)[i][3],
                                                    '30YFixedMortgageRate':Model_res.predict(steps = len(exog), exog_fc = exog)[i][4],
                                                    'lResidentialInvestment':Model_res.predict(steps = len(exog), exog_fc = exog)[i][5]},ignore_index=True)
    
    
    
    forecasts_trans_df = forecast_extract.head(19).copy()
    forecasts_trans_df = forecasts_trans_df[['lConsumption','lNominalMortgageDebt','lCREPriceIndex','lCPI','30YFixedMortgageRate','lResidentialInvestment']]
    out = forecasts_trans_df.copy()
    
    log_list = [1,1,1,1,0,1]
    for lg in range(len(log_list)):
        if log_list[lg]==1:
            out.iloc[:,lg] = np.exp(out.iloc[:,lg])
    out.to_csv('Output/Model 2/ActualforecastModel2.csv')
    
    initial_forecasts_for_plot = out.copy()
    
    results = Model_res
    idx = pd.date_range('1983-06-30', periods=len(df2)-1, freq='Q')
    model_1_data = pd.DataFrame(ahf.difftrans(df2))
    model_1_data.set_index(idx, inplace = True)
    model_1_input_raw_data = model_1_data.copy()
    
    fcast = df2.tail(1)
    fcast = fcast.append(forecasts_trans_df.copy(),ignore_index=True)
    forecasts_new = ahf.difftrans(fcast)
    
    
    n_steps = len(forecasts_new)
    n_variables = len(forecasts_new.columns)
    
    n_steps = len(forecasts_new)
    n_variables = len(forecasts_new.columns)
    
    ## Code for adjusting forecasts
    
    initial_forecasts = forecasts_new.copy()
    initial_forecasts = np.array(initial_forecasts)
    
    irfs = results.irf(n_steps)
    irfs = irfs.orth_irfs
    
    lag_order = 4
    upstream_forecasts = pd.read_csv(
        'Input/Model 2/Model 1 GDP deflat Transformed Output for Model 2.csv',
        index_col=0
        )
    
    # upstream_forecasts = pd.read_csv(
    #     'Model 1 upstream forecasts.csv',
    #     index_col=0, parse_dates=True)
    upstream_forecasts = np.array(upstream_forecasts)  
    
    col_loc_adj_col = [0]
    
    bef_forecast_values= pd.DataFrame(model_1_data.tail(lag_order-1)).transpose()
        
    bef_forecast_values = np.array(bef_forecast_values)  
    
    coeffs = None
    
    new_forecasts = ahf.adjust_forecasts(
                        initial_forecasts,
                        irfs,
                        coeffs,
                        lag_order,
                        upstream_forecasts,
                        col_loc_adj_col,
                        bef_forecast_values,
                        last_iteration=19
                        )
    new_forecasts_df_mod2 = pd.DataFrame(new_forecasts)
     
    new_forecasts_df_mod2.columns = ['lConsumption','lNominalMortgageDebt','lCREPriceIndex','lCPI','30YFixedMortgageRate','lResidentialInvestment']
    
    out = pd.DataFrame()
    for tr in range(new_forecasts_df_mod2.shape[0]):
        
        if tr == 0:
            out = df2.tail(1) + new_forecasts_df_mod2.iloc[tr,:]
        else:
            out = out.append(out.tail(1)+new_forecasts_df_mod2.iloc[tr,:], ignore_index = True)
    log_list = [1,1,1,1,0,1]
    for lg in range(len(log_list)):
        if log_list[lg]==1:
            out.iloc[:,lg] = np.exp(out.iloc[:,lg])
    
    final_output_Model2 = out
    out.to_csv('Output/Model 2/Model2AdjOutput.csv')
    new_adj_final_forecasts = out.copy()
    
    new_forecasts_df_mod2.to_csv('Input/Model 3/Model_2_Output_for_Model_3.csv')
    
    oe_forecasts_df = pd.read_csv('Input/Model 2/OE forecast data for Model 2.csv',
                                  parse_dates=True,
                                  index_col=0)
    new_adj_final_forecasts.index = oe_forecasts_df.index
    initial_forecasts_for_plot.index = oe_forecasts_df.index
    for column in out.columns:
        temp_dict = dict()
        temp_dict['OE_forecast'] = oe_forecasts_df[column]
        temp_dict['initial_forecast'] = initial_forecasts_for_plot[column]
        temp_dict['new_adj_forecast'] = new_adj_final_forecasts[column]
        ax = pd.DataFrame(temp_dict,index=oe_forecasts_df.index).plot(title=column)
        ax.set_ylim(0)
        fig = ax.get_figure()
        fig.savefig('Output/Variations/Variant 1/Model 2 '+column+'.png')
        pd.DataFrame(temp_dict,index=oe_forecasts_df.index).to_csv(
            'Output/Model 2/Adj Forecasts/'+column+\
                '_adj_forecasts_model_2.csv')

################### Model 3 below

def model_3_RS():
    df = pd.read_csv('Input/Model 3/with Retail Sales/Model3QData-RS.csv', index_col=0,parse_dates=True)
    exog = pd.read_csv('Input/Model 3/with Retail Sales/Exog Workplace_oil Model 3.csv', index_col=0,parse_dates=True)
    df.index.freq = "Q"
    exog.index.freq = "Q"
    
    Model3Data = df[['CPI','CCI','IndustrialProduction','CapacityUtilization','Retail Sales','ConsumerCredit']]
    Model3Data.columns = ['lCPI','lCCI','lIndustrialProduction','lCapacityUtilization','lRS','lConsumerCredit']
    
    
    df['lCPI'] = np.log(df['CPI'])
    df['lCCI'] = np.log(df['CCI'])
    df['lIndustrialProduction'] = np.log(df['IndustrialProduction'])
    df['lCapacityUtilization'] = np.log(df['CapacityUtilization'])
    df['lRS'] = np.log(df['Retail Sales'])
    df['lConsumerCredit'] = np.log(df['ConsumerCredit'])
    
    df2 = df.drop(['CPI','CCI','IndustrialProduction','CapacityUtilization','Retail Sales','ConsumerCredit'], axis = 1)
    df2 = df2[['lCPI','lCCI','lIndustrialProduction','lCapacityUtilization','lRS','lConsumerCredit']]
    
    
    
    mod1 = coint_johansen(df2,0,1)
    output = pd.DataFrame([mod1.lr2,mod1.lr1],index=['Max Eigen',"Trace"])
    print('\nCE w/constant intercept\n' ,output.T, '\n')
    print("Critical values(90%, 95% , 99%) of Max Eign\n" , mod1.cvm , '\n')
    print("Critical values(90%, 95% , 99%) of Trace\n" , mod1.cvt, '\n')
    
      
    lo = select_order(df2,maxlags = 7)
    lo.selected_orders
    
    #aic criterion gives 2 lag
    #ar_diff is lag order, coint_rank in no of co integrated reationship
    Model = VECM(df2,exog = exog ,k_ar_diff = 3, coint_rank = 2, deterministic= 'co')
    Model_res = Model.fit()
    
    forecast_extract = pd.DataFrame()
    for i in range(19):
        forecast_extract = forecast_extract.append({'lCPI':Model_res.predict(steps = len(exog), exog_fc = pd.DataFrame(exog))[i][0],
                                                    'lCCI':Model_res.predict(steps = len(exog), exog_fc = pd.DataFrame(exog))[i][1],
                                                    'lIndustrialProduction':Model_res.predict(steps =len(exog), exog_fc = pd.DataFrame(exog ))[i][2],
                                                    'lCapacityUtilization':Model_res.predict(steps = len(exog), exog_fc = pd.DataFrame(exog) )[i][3],
                                                    'lRS':Model_res.predict(steps = len(exog), exog_fc = pd.DataFrame(exog ))[i][4],
                                                    'lConsumerCredit':Model_res.predict(steps = len(exog), exog_fc = pd.DataFrame(exog))[i][5]}
                                                    ,ignore_index=True)
    
    forecasts_trans_df = forecast_extract.head(19).copy()
    forecasts_trans_df = forecasts_trans_df[['lCPI','lCCI','lIndustrialProduction','lCapacityUtilization','lRS','lConsumerCredit']]
    out = forecasts_trans_df.copy()
    
    log_list = [1,1,1,1,1,1]
    for lg in range(len(log_list)):
        if log_list[lg]==1:
            out.iloc[:,lg] = np.exp(out.iloc[:,lg])
    out.to_csv('Output/Model 3/with Retail Sales/ActualforecastModel3.csv')
    initial_forecasts_for_plot = out.copy()
    results = Model_res
    idx = pd.date_range('1980-06-30', periods=len(df2)-1, freq='Q')
    model_1_data = pd.DataFrame(ahf.difftrans(df2))
    model_1_data.set_index(idx, inplace = True)
    model_1_input_raw_data = model_1_data.copy()
    
    
    initial_training_end_date = '2021-03-31'
    
    fcast = df2.tail(1)
    fcast = fcast.append(forecasts_trans_df.copy(),ignore_index=True)
    forecasts_new = ahf.difftrans(fcast)
    
    
    n_steps = len(forecasts_new)
    n_variables = len(forecasts_new.columns)
    
    
    ## Code for adjusting forecasts
    
    
    initial_forecasts = forecasts_new.copy()
    initial_forecasts = np.array(initial_forecasts)
    
    irfs = results.irf(n_steps)
    irfs = irfs.orth_irfs
    
    lag_order = 2
    new_forecasts_df_mod2 = pd.read_csv('Input/Model 3/Model_2_Output_for_Model_3.csv')
    df = pd.read_csv('Input/Model 3/with Retail Sales/Model3QData-RS.csv', index_col=0,parse_dates=True)
    upstream_forecasts = pd.DataFrame(new_forecasts_df_mod2.iloc[:,3])
    upstream_forecasts = np.array(upstream_forecasts)  
    
    col_loc_adj_col = [0]
    
    bef_forecast_values= pd.DataFrame(model_1_data.tail(lag_order-1)).transpose()
        
    bef_forecast_values = np.array(bef_forecast_values)  
    
    coeffs = None
    new_forecasts = ahf.adjust_forecasts(
                        initial_forecasts,
                        irfs,
                        coeffs,
                        lag_order,
                        upstream_forecasts,
                        col_loc_adj_col,
                        bef_forecast_values,
                        last_iteration=19
                        )
    new_forecasts_df_mod3 = pd.DataFrame(new_forecasts)
    
    new_forecasts_df_mod3.columns = ['lCPI','lCCI','lIndustrialProduction','lCapacityUtilization','lRS','lConsumerCredit']
    out = pd.DataFrame()
    for tr in range(new_forecasts_df_mod3.shape[0]):
        
        if tr == 0:
            out = df2.tail(1) + new_forecasts_df_mod3.iloc[tr,:]
        else:
            out = out.append(out.tail(1)+new_forecasts_df_mod3.iloc[tr,:], ignore_index = True)
    
    log_list = [1,1,1,1,1,1]
    for lg in range(len(log_list)):
        if log_list[lg]==1:
            out.iloc[:,lg] = np.exp(out.iloc[:,lg])
    
    final_output_Model3 = out
    
    output_to_model4 = Model3Data.tail(1).append(out).diff(1).iloc[:,3].dropna()
    output_to_model4.to_csv('Input/Model 4/Output Model 3 RS for Model 4.csv')
    out.to_csv('Output/Model 3/with Retail Sales/Model3AdjOutput.csv')

    new_adj_final_forecasts = out.copy()
    
    oe_forecasts_df = pd.read_csv('Input/Model 3/with Retail Sales/OE forecast data for Model 3.csv',
                                  parse_dates=True,
                                  index_col=0)
    new_adj_final_forecasts.index = oe_forecasts_df.index
    initial_forecasts_for_plot.index = oe_forecasts_df.index
    for column in out.columns:
        temp_dict = dict()
        temp_dict['OE_forecast'] = oe_forecasts_df[column]
        temp_dict['initial_forecast'] = initial_forecasts_for_plot[column]
        temp_dict['new_adj_forecast'] = new_adj_final_forecasts[column]
        ax = pd.DataFrame(temp_dict,index=oe_forecasts_df.index).plot(title=column)
        ax.set_ylim(0, np.array(pd.DataFrame(temp_dict,index=forecasts_new.index)).max()*1.5)
        fig = ax.get_figure()
        fig.savefig('Output/Variations/Variant 1/Model 3 '+column+'.png')
        pd.DataFrame(temp_dict,index=oe_forecasts_df.index).to_csv(
            'Output/Model 3/with Retail Sales/Adj Forecasts/'+column+\
                '_adj_forecasts_model_3.csv')

####################### Model 4 below
def model_4_brent():
    df = pd.read_csv('Input/Model 4/with Brent/ConsoData-Paper4.csv', index_col=0,parse_dates=True)
    exog = pd.read_csv('Input/Model 4/with Brent/Exog OilP.csv', index_col=0,parse_dates=True)
    df.index.freq = "Q"
    exog.index.freq = "Q"
    
    df.drop(['RealOilPriceWTI'], axis = 1, inplace = True)
    #df.drop(['RealOilPriceBrent'], axis = 1, inplace = True)
    
    #With constant "0", lagorder "2"
    mod1 = coint_johansen(df,0,1)
    output = pd.DataFrame([mod1.lr2,mod1.lr1],index=['Max Eigen',"Trace"])
    print('\nCE w/constant intercept\n' ,output.T, '\n')
    print("Critical values(90%, 95% , 99%) of Max Eign\n" , mod1.cvm , '\n')
    print("Critical values(90%, 95% , 99%) of Trace\n" , mod1.cvt, '\n')
    
      
    lo = select_order(df,maxlags = 7)
    lo.selected_orders
    
    #aic criterion gives 2 lag
    #ar_diff is lag order, coint_rank in no of co integrated reationship
    Model = VECM(df,exog = exog,k_ar_diff = 2, coint_rank = 1)
    Model_res = Model.fit()
    
    forecast_extract = pd.DataFrame()
    
    for i in range(19):
        forecast_extract = forecast_extract.append({'ldOilProduction':Model_res.predict(steps = len(exog), exog_fc = exog)[i][0],
                                                    'CapacityUtilisation':Model_res.predict(steps = len(exog), exog_fc = exog)[i][1],
                                                    'RealOilPriceBrent':Model_res.predict(steps = len(exog), exog_fc = exog)[i][2],
                                                    },ignore_index=True)
    forecasts_trans_df = forecast_extract.head(19).copy()
    
    forecast_extract.to_csv('Output/Model 4/with Brent/ActualforecastModel4.csv')
    initial_forecasts_for_plot = forecast_extract.copy()
    results = Model_res
    idx = pd.date_range('1987-12-31', periods=len(df)-1, freq='Q')
    model_1_data = pd.DataFrame(ahf.difftrans(df))
    model_1_data.set_index(idx, inplace = True)
    model_1_input_raw_data = model_1_data.copy()
    
    
    fcast = df.tail(1)
    forecasts_trans_df = forecasts_trans_df[['ldOilProduction','CapacityUtilisation','RealOilPriceBrent']]
    fcast = fcast.append(forecasts_trans_df.copy(),ignore_index=True)
    forecasts_new = ahf.difftrans(fcast)
    
    
    n_steps = len(forecasts_new)
    n_variables = len(forecasts_new.columns)
    
    initial_forecasts = forecasts_new.copy()
    initial_forecasts = np.array(initial_forecasts)
    
    irfs = results.irf(n_steps)
    irfs = irfs.orth_irfs
    
    lag_order = 2
    upstream_forecasts = pd.read_csv('Input/Model 4/Output Model 3 RS for Model 4.csv',
                                     index_col=0)
    #upstream_forecasts = pd.DataFrame(output_to_model4)
    upstream_forecasts = np.array(upstream_forecasts)  
    
    col_loc_adj_col = [1]
    
    bef_forecast_values= pd.DataFrame(model_1_data.tail(lag_order-1)).transpose()
        
    bef_forecast_values = np.array(bef_forecast_values)  
    
    coeffs = None
    new_forecasts = ahf.adjust_forecasts(
                        initial_forecasts,
                        irfs,
                        coeffs,
                        lag_order,
                        upstream_forecasts,
                        col_loc_adj_col,
                        bef_forecast_values,
                        last_iteration=19
                        )
    new_forecasts_df_mod4 = pd.DataFrame(new_forecasts)
    
    new_forecasts_df_mod4.columns  = ['ldOilProduction','CapacityUtilisation','RealOilPriceBrent']
    out = pd.DataFrame()
    for tr in range(new_forecasts_df_mod4.shape[0]):
        if tr == 0:
            out = df.tail(1) + new_forecasts_df_mod4.iloc[tr,:]
        else:
            out = out.append(out.tail(1)+new_forecasts_df_mod4.iloc[tr,:], ignore_index = True)
    
    final_output_Model4 = out
            
    out.to_csv('Output/Model 4/with Brent/Model4AdjOutput.csv')
    new_adj_final_forecasts = out.copy()
    
    oe_forecasts_df = pd.read_csv('Input/Model 4/with Brent/OE forecast data for Model 4.csv',
                                  parse_dates=True,
                                  index_col=0)
    
    new_adj_final_forecasts.index = oe_forecasts_df.index
    initial_forecasts_for_plot.index = oe_forecasts_df.index
    
    cpi_input_df = pd.read_csv('Input/Model 4/CPI Input.csv',
                                  parse_dates=True,
                                  index_col=0)
    
    for column in out.columns:
        temp_dict = dict()
        if column == 'RealOilPriceBrent':
            temp_dict['OE_forecast'] = oe_forecasts_df[column] * cpi_input_df['CPI']/100
            temp_dict['initial_forecast'] = initial_forecasts_for_plot[column] * cpi_input_df['CPI']/100
            temp_dict['new_adj_forecast'] = new_adj_final_forecasts[column] * cpi_input_df['CPI']/100
            ax = pd.DataFrame(temp_dict,index=oe_forecasts_df.index).plot(title='Nominal Oil Price Brent')
        else:
            temp_dict['OE_forecast'] = oe_forecasts_df[column]
            temp_dict['initial_forecast'] = initial_forecasts_for_plot[column]
            temp_dict['new_adj_forecast'] = new_adj_final_forecasts[column]
            ax = pd.DataFrame(temp_dict,index=oe_forecasts_df.index).plot(title=column)
        ax.set_ylim(0, np.array(pd.DataFrame(temp_dict,index=forecasts_new.index)).max()*1.5)
        fig = ax.get_figure()
        fig.savefig('Output/Variations/Variant 1/Model 4 '+column+'.png')
        pd.DataFrame(temp_dict,index=oe_forecasts_df.index).to_csv(
            'Output/Model 4/with Brent/Adj Forecasts/'+column+\
                '_adj_forecasts_model_4.csv')